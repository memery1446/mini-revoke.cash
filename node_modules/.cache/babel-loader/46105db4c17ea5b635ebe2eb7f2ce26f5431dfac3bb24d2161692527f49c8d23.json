{"ast":null,"code":"import { ethers } from \"ethers\"; // Import ethers library\nimport getProvider from \"../utils/provider\"; // Importing the default export\nimport { ERC1155_ABI, CONTRACT_ADDRESSES } from \"../constants/abis\"; // Importing ABIs and addresses\n\nconst provider = getProvider(); // Get the provider\nconst erc1155Contract = new ethers.Contract(CONTRACT_ADDRESSES.ERC1155,\n// The ERC-1155 contract address\nERC1155_ABI,\n// The ABI of the ERC-1155 contract\nprovider);\n\n/**\n * Fetch ERC-1155 approvals for a given owner address.\n * @param {string} ownerAddress - The address of the token owner.\n * @returns {Promise<Array>} - A promise that resolves to an array of approvals.\n */\nasync function getERC1155Approvals(ownerAddress) {\n  try {\n    console.log(\"üîç Fetching ERC-1155 approvals for owner:\", ownerAddress);\n\n    // Ensure ownerAddress is valid\n    if (!ethers.utils.isAddress(ownerAddress)) {\n      console.error(\"‚ùå Invalid owner address provided:\", ownerAddress);\n      return []; // Exit if invalid\n    }\n    const spenderAddresses = [CONTRACT_ADDRESSES.MockSpender // Ensure this address is valid\n    ];\n    let approvals = [];\n    for (let spender of spenderAddresses) {\n      console.log(\"Checking approval for spender:\", spender); // Log each spender\n\n      // Validate spender address\n      if (!ethers.utils.isAddress(spender)) {\n        console.error(\"‚ùå Invalid spender address provided:\", spender);\n        return []; // Exit if invalid\n      }\n      const isApproved = await erc1155Contract.isApprovedForAll(ownerAddress, spender);\n      approvals.push({\n        spender,\n        isApproved\n      });\n    }\n    return approvals;\n  } catch (error) {\n    console.error(\"‚ùå Error fetching ERC-1155 approvals:\", error);\n    return []; // Return an empty array in case of an error\n  }\n}\n\n/**\n * Revoke approval for a specific ERC-1155 spender address.\n * @param {string} spenderAddress - The address of the spender to revoke approval for.\n * @returns {Promise<boolean>} - A promise that resolves to true if revoked successfully, or false.\n */\nasync function revokeERC1155Approval(spenderAddress) {\n  try {\n    console.log(\"üö® Revoking approval for ERC-1155 spender:\", spenderAddress);\n    const signer = provider.getSigner();\n    const contractWithSigner = erc1155Contract.connect(signer);\n    const tx = await contractWithSigner.setApprovalForAll(spenderAddress, false);\n    await tx.wait(); // Wait for transaction confirmation\n\n    console.log(\"‚úÖ Approval revoked successfully.\");\n    return true;\n  } catch (error) {\n    console.error(\"‚ùå Error revoking ERC-1155 approval:\", error); // Detailed error logging\n    return false; // Return false in case of an error\n  }\n}\n\n/**\n * Batch revoke approvals for multiple ERC-1155 spender addresses.\n * @param {Array<string>} spenderAddresses - The array of addresses to revoke approval for.\n * @returns {Promise<boolean>} - A promise that resolves to true if all approvals are revoked successfully, or false.\n */\nasync function batchRevokeERC1155Approvals(spenderAddresses) {\n  try {\n    console.log(\"üö® Revoking approvals for multiple ERC-1155 spenders:\", spenderAddresses);\n    const signer = provider.getSigner();\n    const contractWithSigner = erc1155Contract.connect(signer);\n    for (let spender of spenderAddresses) {\n      if (!ethers.utils.isAddress(spender)) {\n        console.error(`‚ùå Invalid spender address: ${spender}`);\n        continue; // Skip this spender if the address is invalid\n      }\n      const tx = await contractWithSigner.setApprovalForAll(spender, false);\n      await tx.wait(); // Wait for transaction confirmation\n    }\n    console.log(\"‚úÖ Batch approval revocations successful.\");\n    return true;\n  } catch (error) {\n    console.error(\"‚ùå Error in batch revoking ERC-1155 approvals:\", error); // Detailed error logging\n    return false; // Return false in case of an error\n  }\n}\nexport { getERC1155Approvals, revokeERC1155Approval, batchRevokeERC1155Approvals };","map":{"version":3,"names":["ethers","getProvider","ERC1155_ABI","CONTRACT_ADDRESSES","provider","erc1155Contract","Contract","ERC1155","getERC1155Approvals","ownerAddress","console","log","utils","isAddress","error","spenderAddresses","MockSpender","approvals","spender","isApproved","isApprovedForAll","push","revokeERC1155Approval","spenderAddress","signer","getSigner","contractWithSigner","connect","tx","setApprovalForAll","wait","batchRevokeERC1155Approvals"],"sources":["/Users/markemery/mini.revoke/src/utils/erc1155Approvals.js"],"sourcesContent":["import { ethers } from \"ethers\"; // Import ethers library\nimport getProvider from \"../utils/provider\"; // Importing the default export\nimport { ERC1155_ABI, CONTRACT_ADDRESSES } from \"../constants/abis\"; // Importing ABIs and addresses\n\nconst provider = getProvider(); // Get the provider\nconst erc1155Contract = new ethers.Contract(\n    CONTRACT_ADDRESSES.ERC1155, // The ERC-1155 contract address\n    ERC1155_ABI, // The ABI of the ERC-1155 contract\n    provider\n);\n\n/**\n * Fetch ERC-1155 approvals for a given owner address.\n * @param {string} ownerAddress - The address of the token owner.\n * @returns {Promise<Array>} - A promise that resolves to an array of approvals.\n */\nasync function getERC1155Approvals(ownerAddress) {\n    try {\n        console.log(\"üîç Fetching ERC-1155 approvals for owner:\", ownerAddress);\n        \n        // Ensure ownerAddress is valid\n        if (!ethers.utils.isAddress(ownerAddress)) {\n            console.error(\"‚ùå Invalid owner address provided:\", ownerAddress);\n            return []; // Exit if invalid\n        }\n\n        const spenderAddresses = [\n            CONTRACT_ADDRESSES.MockSpender // Ensure this address is valid\n        ];\n\n        let approvals = [];\n        for (let spender of spenderAddresses) {\n            console.log(\"Checking approval for spender:\", spender); // Log each spender\n\n            // Validate spender address\n            if (!ethers.utils.isAddress(spender)) {\n                console.error(\"‚ùå Invalid spender address provided:\", spender);\n                return []; // Exit if invalid\n            }\n\n            const isApproved = await erc1155Contract.isApprovedForAll(ownerAddress, spender);\n            approvals.push({ spender, isApproved });\n        }\n\n        return approvals;\n    } catch (error) {\n        console.error(\"‚ùå Error fetching ERC-1155 approvals:\", error);\n        return []; // Return an empty array in case of an error\n    }\n}\n\n/**\n * Revoke approval for a specific ERC-1155 spender address.\n * @param {string} spenderAddress - The address of the spender to revoke approval for.\n * @returns {Promise<boolean>} - A promise that resolves to true if revoked successfully, or false.\n */\nasync function revokeERC1155Approval(spenderAddress) {\n    try {\n        console.log(\"üö® Revoking approval for ERC-1155 spender:\", spenderAddress);\n        const signer = provider.getSigner();\n        const contractWithSigner = erc1155Contract.connect(signer);\n\n        const tx = await contractWithSigner.setApprovalForAll(spenderAddress, false);\n        await tx.wait(); // Wait for transaction confirmation\n\n        console.log(\"‚úÖ Approval revoked successfully.\");\n        return true;\n    } catch (error) {\n        console.error(\"‚ùå Error revoking ERC-1155 approval:\", error); // Detailed error logging\n        return false; // Return false in case of an error\n    }\n}\n\n/**\n * Batch revoke approvals for multiple ERC-1155 spender addresses.\n * @param {Array<string>} spenderAddresses - The array of addresses to revoke approval for.\n * @returns {Promise<boolean>} - A promise that resolves to true if all approvals are revoked successfully, or false.\n */\nasync function batchRevokeERC1155Approvals(spenderAddresses) {\n    try {\n        console.log(\"üö® Revoking approvals for multiple ERC-1155 spenders:\", spenderAddresses);\n        const signer = provider.getSigner();\n        const contractWithSigner = erc1155Contract.connect(signer);\n\n        for (let spender of spenderAddresses) {\n            if (!ethers.utils.isAddress(spender)) {\n                console.error(`‚ùå Invalid spender address: ${spender}`);\n                continue; // Skip this spender if the address is invalid\n            }\n            const tx = await contractWithSigner.setApprovalForAll(spender, false);\n            await tx.wait(); // Wait for transaction confirmation\n        }\n\n        console.log(\"‚úÖ Batch approval revocations successful.\");\n        return true;\n    } catch (error) {\n        console.error(\"‚ùå Error in batch revoking ERC-1155 approvals:\", error); // Detailed error logging\n        return false; // Return false in case of an error\n    }\n}\n\nexport { getERC1155Approvals, revokeERC1155Approval, batchRevokeERC1155Approvals };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}