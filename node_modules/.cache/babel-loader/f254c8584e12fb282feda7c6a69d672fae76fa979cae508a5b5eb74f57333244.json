{"ast":null,"code":"import { ethers, Contract } from \"ethers\";\n\n/** Function to get ERC-20 Approvals */\nexport async function getERC20Approvals(tokenContracts, ownerAddress, provider) {\n  const abi = [\"function allowance(address owner, address spender) view returns (uint256)\"];\n  let approvals = [];\n\n  // üöÄ Hardhat-compatible spender addresses (NO ENS!)\n  const spenderAddresses = [\"0x0000000000000000000000000000000000000000\" // Dummy zero address to prevent ENS lookups\n  ];\n  for (let tokenAddress of tokenContracts) {\n    const contract = new Contract(tokenAddress, abi, provider);\n    for (let spender of spenderAddresses) {\n      console.log(`üõ†Ô∏è Checking allowance for spender: ${spender}`);\n      try {\n        const allowance = await contract.allowance(ownerAddress, spender);\n        if (allowance > 0) {\n          approvals.push({\n            contract: tokenAddress,\n            type: \"ERC-20\",\n            spender: spender,\n            amount: allowance.toString()\n          });\n        }\n      } catch (error) {\n        console.error(`‚ùå Error fetching allowance for spender: ${spender}`, error);\n      }\n    }\n  }\n  console.log(\"‚úÖ ERC-20 Approvals Fetched:\", approvals);\n  return approvals;\n}","map":{"version":3,"names":["ethers","Contract","getERC20Approvals","tokenContracts","ownerAddress","provider","abi","approvals","spenderAddresses","tokenAddress","contract","spender","console","log","allowance","push","type","amount","toString","error"],"sources":["/Users/markemery/mini.revoke/src/utils/erc20Approvals.js"],"sourcesContent":["import { ethers, Contract } from \"ethers\";\n\n/** Function to get ERC-20 Approvals */\nexport async function getERC20Approvals(tokenContracts, ownerAddress, provider) {\n    const abi = [\"function allowance(address owner, address spender) view returns (uint256)\"];\n\n    let approvals = [];\n\n    // üöÄ Hardhat-compatible spender addresses (NO ENS!)\n    const spenderAddresses = [\n        \"0x0000000000000000000000000000000000000000\" // Dummy zero address to prevent ENS lookups\n    ];\n\n    for (let tokenAddress of tokenContracts) {\n        const contract = new Contract(tokenAddress, abi, provider);\n\n        for (let spender of spenderAddresses) {\n            console.log(`üõ†Ô∏è Checking allowance for spender: ${spender}`);\n\n            try {\n                const allowance = await contract.allowance(ownerAddress, spender);\n                if (allowance > 0) {\n                    approvals.push({\n                        contract: tokenAddress,\n                        type: \"ERC-20\",\n                        spender: spender,\n                        amount: allowance.toString()\n                    });\n                }\n            } catch (error) {\n                console.error(`‚ùå Error fetching allowance for spender: ${spender}`, error);\n            }\n        }\n    }\n\n    console.log(\"‚úÖ ERC-20 Approvals Fetched:\", approvals);\n    return approvals;\n}\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,QAAQ,QAAQ,QAAQ;;AAEzC;AACA,OAAO,eAAeC,iBAAiBA,CAACC,cAAc,EAAEC,YAAY,EAAEC,QAAQ,EAAE;EAC5E,MAAMC,GAAG,GAAG,CAAC,2EAA2E,CAAC;EAEzF,IAAIC,SAAS,GAAG,EAAE;;EAElB;EACA,MAAMC,gBAAgB,GAAG,CACrB,4CAA4C,CAAC;EAAA,CAChD;EAED,KAAK,IAAIC,YAAY,IAAIN,cAAc,EAAE;IACrC,MAAMO,QAAQ,GAAG,IAAIT,QAAQ,CAACQ,YAAY,EAAEH,GAAG,EAAED,QAAQ,CAAC;IAE1D,KAAK,IAAIM,OAAO,IAAIH,gBAAgB,EAAE;MAClCI,OAAO,CAACC,GAAG,CAAC,uCAAuCF,OAAO,EAAE,CAAC;MAE7D,IAAI;QACA,MAAMG,SAAS,GAAG,MAAMJ,QAAQ,CAACI,SAAS,CAACV,YAAY,EAAEO,OAAO,CAAC;QACjE,IAAIG,SAAS,GAAG,CAAC,EAAE;UACfP,SAAS,CAACQ,IAAI,CAAC;YACXL,QAAQ,EAAED,YAAY;YACtBO,IAAI,EAAE,QAAQ;YACdL,OAAO,EAAEA,OAAO;YAChBM,MAAM,EAAEH,SAAS,CAACI,QAAQ,CAAC;UAC/B,CAAC,CAAC;QACN;MACJ,CAAC,CAAC,OAAOC,KAAK,EAAE;QACZP,OAAO,CAACO,KAAK,CAAC,2CAA2CR,OAAO,EAAE,EAAEQ,KAAK,CAAC;MAC9E;IACJ;EACJ;EAEAP,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAEN,SAAS,CAAC;EACrD,OAAOA,SAAS;AACpB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}